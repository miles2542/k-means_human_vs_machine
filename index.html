<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive K-Means Algorithm | Human vs Machine</title>
    <style>
        :root {
            --eco-red: #E3120B;
            --eco-blue: #004687;
            --eco-bg: #F3F3F3;
            --eco-panel: #FFFFFF;
            --eco-text: #222222;
            --eco-subtext: #595959;
            --eco-border: #D7D7D7;
            --eco-accent: #2c3e50;

            /* Cluster Palette */
            --c0: #007EA7;
            --c1: #D64933;
            --c2: #F0C419;
            --c3: #4B3F72;
            --c4: #58A4B0;
            --c5: #6D6875;
        }

        * {
            box-sizing: border-box;
            user-select: none;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: "Segoe UI", "Roboto", "Helvetica Neue", sans-serif;
            background-color: var(--eco-bg);
            color: var(--eco-text);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* --- Header --- */
        header {
            background: white;
            padding: 15px 40px;
            border-top: 4px solid var(--eco-red);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            display: flex;
            justify-content: space-between;
            align-items: center;
            z-index: 10;
        }

        .brand h1 {
            font-family: "Montserrat", serif;
            font-size: 26px;
            margin: 0;
            letter-spacing: -0.5px;
        }

        .brand span {
            font-family: "Segoe UI", sans-serif;
            font-size: 13px;
            color: var(--eco-subtext);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-left: 10px;
        }

        /* --- Layout --- */
        #workspace {
            flex: 1;
            display: flex;
            position: relative;
            overflow: hidden;
        }

        /* --- Sidebar --- */
        #sidebar {
            width: 320px;
            background: var(--eco-panel);
            border-right: 1px solid var(--eco-border);
            padding: 25px;
            display: flex;
            flex-direction: column;
            gap: 25px;
            overflow-y: auto;
            z-index: 5;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.02);
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .control-header {
            font-size: 11px;
            font-weight: 800;
            text-transform: uppercase;
            color: var(--eco-red);
            border-bottom: 2px solid var(--eco-red);
            padding-bottom: 6px;
            margin-bottom: 5px;
            letter-spacing: 0.5px;
        }

        /* Inputs */
        label {
            font-size: 13px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 500;
            color: var(--eco-text);
        }

        input[type="range"] {
            width: 100%;
            height: 4px;
            background: #ddd;
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: var(--eco-blue);
            border-radius: 50%;
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
        }

        select {
            width: 100%;
            padding: 10px;
            border: 1px solid var(--eco-border);
            border-radius: 4px;
            font-family: inherit;
            background: white;
            font-size: 13px;
        }

        /* Buttons */
        .btn {
            padding: 12px;
            border: none;
            border-radius: 4px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
            font-size: 13px;
            letter-spacing: 0.5px;
            position: relative;
        }

        .btn:active {
            transform: translateY(1px);
        }

        .btn-primary {
            background: var(--eco-red);
            color: white;
            box-shadow: 0 2px 4px rgba(227, 18, 11, 0.2);
        }

        .btn-primary:hover:not(:disabled) {
            background: #c00f09;
            box-shadow: 0 4px 8px rgba(227, 18, 11, 0.3);
        }

        .btn-primary:disabled {
            background: #e0e0e0;
            color: #999;
            cursor: not-allowed;
            box-shadow: none;
        }

        .btn-secondary {
            background: white;
            border: 1px solid var(--eco-border);
            color: var(--eco-text);
        }

        .btn-secondary:hover:not(:disabled) {
            background: #f9f9f9;
            border-color: #999;
        }

        .btn-secondary:disabled {
            color: #ccc;
            border-color: #eee;
            cursor: not-allowed;
        }

        .btn-group {
            display: flex;
            gap: 10px;
        }

        .btn-group .btn {
            flex: 1;
        }

        /* --- Status Panel (New) --- */
        #status-panel {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 6px;
            padding: 15px;
            margin-top: 10px;
            display: none;
            /* Hidden by default */
        }

        .status-row {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            margin-bottom: 6px;
            color: var(--eco-subtext);
        }

        .status-val {
            font-weight: 700;
            color: var(--eco-text);
            font-feature-settings: "tnum";
        }

        .status-badge {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 10px;
            text-transform: uppercase;
            font-weight: bold;
            letter-spacing: 0.5px;
        }

        .bg-assign {
            background: #e3f2fd;
            color: #1565c0;
        }

        .bg-update {
            background: #fff3e0;
            color: #ef6c00;
        }

        .bg-done {
            background: #e8f5e9;
            color: #2e7d32;
        }

        /* --- Results Table --- */
        #result-box {
            display: none;
            border-top: 1px solid var(--eco-border);
            padding-top: 20px;
            margin-top: 10px;
            animation: fadeIn 0.5s ease;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .comp-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 13px;
            margin-top: 10px;
        }

        .comp-table th {
            text-align: left;
            color: var(--eco-subtext);
            padding-bottom: 8px;
            font-weight: 600;
            border-bottom: 1px solid #eee;
        }

        .comp-table td {
            padding: 8px 0;
            border-bottom: 1px solid #f5f5f5;
        }

        .comp-table td:last-child {
            text-align: right;
            font-weight: 700;
            color: var(--eco-blue);
        }

        .result-summary {
            font-size: 13px;
            line-height: 1.5;
            color: var(--eco-text);
            background: #fff8e1;
            padding: 10px;
            border-left: 3px solid #ffc107;
            margin-top: 15px;
            border-radius: 0 4px 4px 0;
        }

        /* --- Canvas Wrapper --- */
        #canvas-wrapper {
            flex: 1;
            position: relative;
            background: #eef2f5;
            cursor: crosshair;
            overflow: hidden;
        }

        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        #voronoi-canvas {
            opacity: 0.45;
        }

        /* --- Overlay Toast --- */
        #overlay-ui {
            position: absolute;
            top: 25px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 255, 255, 0.95);
            padding: 12px 24px;
            border-radius: 30px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            font-size: 14px;
            font-weight: 600;
            pointer-events: none;
            border: 1px solid rgba(0, 0, 0, 0.05);
            transition: opacity 0.3s;
            color: var(--eco-accent);
            z-index: 20;
        }

        /* --- Toggle Switch --- */
        .toggle-row {
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 13px;
        }

        .toggle {
            position: relative;
            display: inline-block;
            width: 36px;
            height: 20px;
        }

        .toggle input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 34px;
        }

        .slider:before {
            position: absolute;
            content: "";
            height: 14px;
            width: 14px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked+.slider {
            background-color: var(--eco-blue);
        }

        input:checked+.slider:before {
            transform: translateX(16px);
        }

        /* Custom Tooltip */
        [data-tooltip]:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: #333;
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 11px;
            white-space: nowrap;
            opacity: 0.9;
            pointer-events: none;
            margin-bottom: 5px;
        }
    </style>
</head>

<body>

    <header>
        <div class="brand">
            <h1>K-Means: Human vs Machine</h1>
            <span>v1.3 by Miles</span>
        </div>
        <!-- Simple Top Stats -->
        <div style="font-size: 12px; font-weight: 600; color: var(--eco-subtext);">
            N = <span id="disp-n" style="color:var(--eco-text)">300</span>
        </div>
    </header>

    <div id="workspace">
        <!-- Sidebar Controls -->
        <aside id="sidebar">

            <!-- Data Generation -->
            <div class="control-group">
                <div class="control-header">1. Dataset Topology</div>
                <select id="data-type" onchange="Game.reset()">
                    <option value="gaussian">Gaussian Blobs (Standard)</option>
                    <option value="aniso">Anisotropic (Stretched)</option>
                    <option value="rings">Concentric Rings (Linear Fail)</option>
                    <option value="spirals">Twin Spirals (Hard)</option>
                    <option value="uniform">Uniform Noise (No Cluster)</option>
                    <option value="smiley">Smiley Face (Pattern)</option>
                </select>

                <label title="Controls the standard deviation of clusters">
                    <span>Spread / Noise</span>
                    <span id="val-noise">1.0</span>
                </label>
                <input type="range" id="param-noise" min="0.5" max="3.0" step="0.1" value="1.0"
                    oninput="updateVal('val-noise', this.value); Game.requestDataRegen()">
            </div>

            <!-- Params -->
            <div class="control-group">
                <div class="control-header">2. Algorithm Params</div>
                <label>
                    <span>Clusters (K)</span>
                    <span id="val-k">3</span>
                </label>
                <input type="range" id="param-k" min="2" max="6" step="1" value="3"
                    oninput="updateVal('val-k', this.value); Game.reset()">
            </div>

            <!-- Visualization -->
            <div class="control-group">
                <div class="control-header">3. Visualization</div>
                <div class="toggle-row">
                    <span>Show Voronoi Regions</span>
                    <label class="toggle">
                        <input type="checkbox" id="check-voronoi" checked onchange="Game.toggleVoronoi()">
                        <span class="slider"></span>
                    </label>
                </div>
            </div>

            <!-- Status Panel (Live) -->
            <div id="status-panel">
                <div class="status-row">
                    <span>State</span>
                    <span id="stat-phase" class="status-badge bg-assign">Idle</span>
                </div>
                <div class="status-row">
                    <span>Iteration</span>
                    <span id="stat-iter" class="status-val">0</span>
                </div>
                <div class="status-row">
                    <span>Inertia</span>
                    <span id="stat-inertia" class="status-val">--</span>
                </div>
            </div>

            <!-- Controls -->
            <div class="control-group" style="margin-top:auto">
                <div class="control-header">Controls</div>
                <button class="btn btn-primary" id="btn-run" onclick="Game.runAnimation()" disabled
                    data-tooltip="Auto-runs until convergence">
                    Auto-run algorithm
                </button>
                <div class="btn-group">
                    <button class="btn btn-secondary" onclick="Game.stepForward()" id="btn-step" disabled
                        data-tooltip="Advance one step (Assign or Update)">
                        Step +1
                    </button>
                    <button class="btn btn-secondary" onclick="Game.reset()">New</button>
                </div>
            </div>

            <!-- Final Results -->
            <div id="result-box">
                <div class="control-header">Performance Analysis</div>
                <table class="comp-table">
                    <thead>
                        <tr>
                            <th>Metric</th>
                            <th style="text-align:right; color:#000">Human</th>
                            <th style="text-align:right; color:#000">Algorithm</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Inertia (Lower is Better)</td>
                            <td id="res-human-inertia">--</td>
                            <td id="res-ai-inertia">--</td>
                        </tr>
                        <tr>
                            <td>Iterations</td>
                            <td>N/A</td>
                            <td id="res-ai-iter">--</td>
                        </tr>
                    </tbody>
                </table>
                <div id="res-summary" class="result-summary">
                    <!-- Dynamic Text injected here -->
                </div>
            </div>

        </aside>

        <!-- Main Canvas -->
        <div id="canvas-wrapper">
            <canvas id="voronoi-canvas"></canvas>
            <canvas id="main-canvas"></canvas>
            <div id="overlay-ui">Place <b>3</b> centroids to start.</div>
        </div>
    </div>

    <script>
        /**
         * K-MEANS INTERACTIVE ENGINE V2.0
         * "Outstanding" Quality Codebase
         */

        /* --- UTILITIES --- */
        const Utils = {
            rand: (min, max) => Math.random() * (max - min) + min,
            randNormal: (mean, std) => {
                let u = 0, v = 0;
                while (u === 0) u = Math.random();
                while (v === 0) v = Math.random();
                return mean + (Math.sqrt(-2.0 * Math.log(u)) * Math.cos(2.0 * Math.PI * v)) * std;
            },
            distSq: (p1, p2) => (p1.x - p2.x) ** 2 + (p1.y - p2.y) ** 2,
            lerp: (a, b, t) => a + (b - a) * t,
            fmtNum: (n) => Math.round(n).toLocaleString(),
            // Distinct Colors for up to 6 clusters
            getClusterColor: (k, alpha = 1) => {
                const colors = [
                    `rgba(0, 126, 167, ${alpha})`,   // Ocean Blue
                    `rgba(214, 73, 51, ${alpha})`,   // Rust Red
                    `rgba(240, 196, 25, ${alpha})`,  // Mustard Yellow
                    `rgba(75, 63, 114, ${alpha})`,   // Deep Purple
                    `rgba(88, 164, 176, ${alpha})`,  // Teal
                    `rgba(109, 104, 117, ${alpha})`  // Grey
                ];
                return colors[k % colors.length];
            }
        };

        /* --- DATA GENERATION --- */
        class DataEngine {
            constructor(w, h) { this.w = w; this.h = h; }

            generate(type, k, noise) {
                let points = [];
                const n = 300; // Fixed size
                const nPerK = Math.floor(n / k);

                if (type === 'smiley') {
                    // Custom pattern: Face Outline, Eyes, Smile
                    const cx = this.w / 2, cy = this.h / 2, r = Math.min(this.w, this.h) / 2.5;
                    // Face
                    for (let i = 0; i < 120; i++) {
                        const theta = Utils.rand(0, Math.PI * 2);
                        points.push(this.pt(cx + r * Math.cos(theta), cy + r * Math.sin(theta), noise));
                    }
                    // Eyes
                    for (let i = 0; i < 40; i++) points.push(this.pt(cx - r * 0.35, cy - r * 0.2, noise / 2));
                    for (let i = 0; i < 40; i++) points.push(this.pt(cx + r * 0.35, cy - r * 0.2, noise / 2));
                    // Smile
                    for (let i = 0; i < 100; i++) {
                        const theta = Utils.rand(0.2 * Math.PI, 0.8 * Math.PI);
                        points.push(this.pt(cx + r * 0.6 * Math.cos(theta), cy + r * 0.6 * Math.sin(theta), noise / 2));
                    }
                }
                else if (type === 'rings') {
                    const cx = this.w / 2, cy = this.h / 2;
                    for (let i = 0; i < k; i++) {
                        const rad = (i + 1) * (Math.min(this.w, this.h) / (2 * k + 1)) * 1.5;
                        for (let j = 0; j < nPerK; j++) {
                            const theta = Utils.rand(0, Math.PI * 2);
                            points.push(this.pt(cx + rad * Math.cos(theta), cy + rad * Math.sin(theta), noise));
                        }
                    }
                }
                else if (type === 'spirals') {
                    const cx = this.w / 2, cy = this.h / 2;
                    for (let i = 0; i < k; i++) {
                        for (let j = 0; j < nPerK; j++) {
                            const t = j / nPerK;
                            const angle = t * 3 * Math.PI + (i * (Math.PI * 2) / k);
                            const r = t * (Math.min(this.w, this.h) / 2.2);
                            points.push(this.pt(cx + r * Math.cos(angle), cy + r * Math.sin(angle), noise));
                        }
                    }
                }
                else if (type === 'gaussian' || type === 'aniso') {
                    for (let i = 0; i < k; i++) {
                        const cx = Utils.rand(this.w * 0.2, this.w * 0.8);
                        const cy = Utils.rand(this.h * 0.2, this.h * 0.8);
                        for (let j = 0; j < nPerK; j++) {
                            let px = Utils.randNormal(0, 25 * noise);
                            let py = Utils.randNormal(0, 25 * noise);
                            if (type === 'aniso') px *= 4; // Stretch
                            // Rotate aniso
                            if (type === 'aniso') {
                                const ang = 1; // Fixed angle for simplicity
                                const rotX = px * Math.cos(ang) - py * Math.sin(ang);
                                const rotY = px * Math.sin(ang) + py * Math.cos(ang);
                                px = rotX; py = rotY;
                            }
                            points.push({ x: cx + px, y: cy + py, cluster: -1, color: '#aaa' });
                        }
                    }
                }
                else {
                    // Uniform
                    for (let i = 0; i < n; i++) points.push(this.pt(Utils.rand(0, this.w), Utils.rand(0, this.h), 0));
                }

                // Shuffle to avoid index bias
                return points.sort(() => Math.random() - 0.5);
            }

            pt(x, y, noise) {
                return {
                    x: x + Utils.randNormal(0, 5 * noise),
                    y: y + Utils.randNormal(0, 5 * noise),
                    cluster: -1,
                    color: '#aaa'
                };
            }
        }

        /* --- RENDERER (Dual Canvas) --- */
        class Renderer {
            constructor(mainId, bgId) {
                this.main = document.getElementById(mainId);
                this.ctx = this.main.getContext('2d');
                this.bg = document.getElementById(bgId);
                this.bgCtx = this.bg.getContext('2d');

                this.dpr = window.devicePixelRatio || 1;
                this.bgScale = 0.2; // 20% resolution for performance

                this.resize();
                window.addEventListener('resize', () => this.resize());
            }

            resize() {
                const p = this.main.parentElement;
                this.w = p.clientWidth;
                this.h = p.clientHeight;

                // High DPI Main
                this.main.width = this.w * this.dpr;
                this.main.height = this.h * this.dpr;
                this.ctx.scale(this.dpr, this.dpr);

                // Low Res Background
                this.bg.width = this.w * this.bgScale;
                this.bg.height = this.h * this.bgScale;
            }

            clear() { this.ctx.clearRect(0, 0, this.w, this.h); }

            drawPoints(points) {
                points.forEach(p => {
                    this.ctx.beginPath();
                    this.ctx.fillStyle = p.color;
                    this.ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                    this.ctx.fill();
                });
            }

            drawCentroids(centroids, isActive = false) {
                centroids.forEach((c, i) => {
                    const color = isActive ? Utils.getClusterColor(i) : '#E3120B';

                    this.ctx.beginPath();
                    this.ctx.strokeStyle = 'white';
                    this.ctx.lineWidth = 4;
                    this.ctx.lineCap = 'round';

                    // X Mark
                    const s = 8;
                    this.ctx.moveTo(c.x - s, c.y - s); this.ctx.lineTo(c.x + s, c.y + s);
                    this.ctx.moveTo(c.x + s, c.y - s); this.ctx.lineTo(c.x - s, c.y + s);
                    this.ctx.stroke();

                    this.ctx.strokeStyle = color;
                    this.ctx.lineWidth = 2.5;
                    this.ctx.stroke();
                });
            }

            // Optimized Voronoi
            drawVoronoi(centroids, enabled) {
                if (!enabled || centroids.length === 0) {
                    this.bgCtx.clearRect(0, 0, this.bg.width, this.bg.height);
                    return;
                }

                const w = this.bg.width, h = this.bg.height;
                const imgData = this.bgCtx.createImageData(w, h);
                const d = imgData.data;

                // Pre-calculate colors
                const colors = centroids.map((_, i) => {
                    // Parse rgba from helper (hacky but fast)
                    const str = Utils.getClusterColor(i, 1);
                    const match = str.match(/\d+(\.\d+)?/g);
                    return [parseInt(match[0]), parseInt(match[1]), parseInt(match[2])];
                });

                for (let y = 0; y < h; y++) {
                    for (let x = 0; x < w; x++) {
                        const rx = x / this.bgScale;
                        const ry = y / this.bgScale;

                        let minD = Infinity, idx = 0;
                        for (let i = 0; i < centroids.length; i++) {
                            const dist = (centroids[i].x - rx) ** 2 + (centroids[i].y - ry) ** 2;
                            if (dist < minD) { minD = dist; idx = i; }
                        }

                        const ptr = (y * w + x) * 4;
                        const col = colors[idx];
                        d[ptr] = col[0];
                        d[ptr + 1] = col[1];
                        d[ptr + 2] = col[2];
                        d[ptr + 3] = 40; // Alpha
                    }
                }
                this.bgCtx.putImageData(imgData, 0, 0);
            }
        }

        /* --- LOGIC KERNEL --- */
        const Kernel = {
            assign: (points, centroids) => {
                let inertia = 0;
                // Don't mutate original points array immediately, return new assignments
                const assignments = points.map(p => {
                    let minD = Infinity, cIdx = -1;
                    centroids.forEach((c, i) => {
                        const d = Utils.distSq(p, c);
                        if (d < minD) { minD = d; cIdx = i; }
                    });
                    inertia += minD;
                    return cIdx;
                });
                return { assignments, inertia };
            },

            update: (points, assignments, k) => {
                const sums = Array(k).fill(0).map(() => ({ x: 0, y: 0, count: 0 }));
                points.forEach((p, i) => {
                    const c = assignments[i];
                    sums[c].x += p.x;
                    sums[c].y += p.y;
                    sums[c].count++;
                });
                // Calculate new centroids
                return sums.map(s => s.count === 0 ? null : { x: s.x / s.count, y: s.y / s.count });
            }
        };

        /* --- GAME ENGINE --- */
        const Game = {
            state: 'SETUP', // SETUP, PLACING, READY, RUNNING, FINISHED

            // Config
            k: 3,
            points: [],
            userCentroids: [],

            // AI Runtime
            timeline: [], // Stores snapshots of the algorithm
            timeIdx: 0,

            init: function () {
                this.renderer = new Renderer('main-canvas', 'voronoi-canvas');
                this.dataGen = new DataEngine(this.renderer.w, this.renderer.h);

                // Event Listeners
                const cvs = document.getElementById('canvas-wrapper');
                cvs.addEventListener('mousedown', e => this.onClick(e));
                cvs.addEventListener('mousemove', e => this.onDrag(e));
                cvs.addEventListener('mouseup', () => this.dragIdx = -1);

                this.reset();
            },

            reset: function () {
                this.state = 'SETUP';
                this.userCentroids = [];
                this.timeline = [];
                this.timeIdx = 0;

                // Read Config
                this.k = parseInt(document.getElementById('param-k').value);
                const type = document.getElementById('data-type').value;
                const noise = parseFloat(document.getElementById('param-noise').value);

                // Generate
                this.points = this.dataGen.generate(type, this.k, noise);

                // Reset UI
                this.updateUI();
                this.renderer.resize();
                this.renderStatic();

                // Start
                this.state = 'PLACING';
                this.toast(`Click to place ${this.k} Centroids`);

                // Clear Results
                document.getElementById('result-box').style.display = 'none';
                document.getElementById('status-panel').style.display = 'none';
            },

            requestDataRegen: function () {
                if (this.timer) clearTimeout(this.timer);
                this.timer = setTimeout(() => this.reset(), 200);
            },

            /* INPUT HANDLING */
            onClick: function (e) {
                const rect = this.renderer.main.getBoundingClientRect();
                const x = (e.clientX - rect.left);
                const y = (e.clientY - rect.top);

                if (e.shiftKey) {
                    this.points.push({ x, y, cluster: -1, color: '#aaa' });
                    this.renderStatic();
                    return;
                }

                if (this.state === 'PLACING') {
                    if (this.userCentroids.length < this.k) {
                        this.userCentroids.push({ x, y });
                        if (this.userCentroids.length === this.k) {
                            this.state = 'READY';
                            this.calculateUserScore();
                            this.toast("Ready. Run Algorithm or Adjust Centroids.");
                        } else {
                            this.toast(`Place ${this.k - this.userCentroids.length} more`);
                        }
                        this.renderStatic();
                    }
                    this.updateUI();
                } else if (this.state === 'READY') {
                    // Check drag
                    this.dragIdx = this.userCentroids.findIndex(c => Utils.distSq(c, { x, y }) < 900);
                }
            },

            onDrag: function (e) {
                if (this.dragIdx > -1 && this.state === 'READY') {
                    const rect = this.renderer.main.getBoundingClientRect();
                    this.userCentroids[this.dragIdx] = {
                        x: e.clientX - rect.left,
                        y: e.clientY - rect.top
                    };
                    this.calculateUserScore();
                    this.renderStatic();
                }
            },

            /* CORE LOGIC */
            calculateUserScore: function () {
                const res = Kernel.assign(this.points, this.userCentroids);
                this.userInertia = res.inertia;
                // Color points for user view
                this.points.forEach((p, i) => {
                    p.color = Utils.getClusterColor(res.assignments[i]);
                });
                document.getElementById('res-human-inertia').innerText = Utils.fmtNum(res.inertia);
            },

            // Pre-calculate the entire AI sequence
            prepareTimeline: function () {
                // Initialize AI with random centroids (K-Means++)
                let cents = [this.points[Math.floor(Math.random() * this.points.length)]];
                while (cents.length < this.k) {
                    let dists = this.points.map(p => Math.min(...cents.map(c => Utils.distSq(p, c))));
                    let sum = dists.reduce((a, b) => a + b);
                    let r = Math.random() * sum;
                    for (let i = 0; i < dists.length; i++) {
                        r -= dists[i];
                        if (r <= 0) { cents.push(this.points[i]); break; }
                    }
                }

                // Convert to simple objects
                let currCentroids = cents.map(c => ({ x: c.x, y: c.y }));
                this.timeline = [];

                // Snapshot 0: Initial State
                this.timeline.push({
                    phase: 'INIT',
                    centroids: JSON.parse(JSON.stringify(currCentroids)),
                    assignments: Array(this.points.length).fill(-1),
                    inertia: 0
                });

                let converged = false;
                let iter = 1;

                while (!converged && iter < 30) {
                    // Phase A: Assign
                    const res = Kernel.assign(this.points, currCentroids);
                    this.timeline.push({
                        phase: 'ASSIGN',
                        centroids: JSON.parse(JSON.stringify(currCentroids)),
                        assignments: res.assignments,
                        inertia: res.inertia,
                        iter: iter
                    });

                    // Phase B: Update
                    const newCents = Kernel.update(this.points, res.assignments, this.k);
                    // Handle empty clusters (rare but possible) - keep old pos
                    const cleanCents = newCents.map((c, i) => c || currCentroids[i]);

                    // Check convergence
                    let shift = 0;
                    currCentroids.forEach((c, i) => shift += Utils.distSq(c, cleanCents[i]));

                    currCentroids = cleanCents;
                    this.timeline.push({
                        phase: 'UPDATE',
                        centroids: JSON.parse(JSON.stringify(currCentroids)),
                        assignments: res.assignments,
                        inertia: res.inertia, // Inertia doesn't change on update step technically, but geometry does
                        iter: iter
                    });

                    if (shift < 1) converged = true;
                    iter++;
                }

                this.aiFinalInertia = this.timeline[this.timeline.length - 1].inertia;
            },

            /* ANIMATION CONTROL */
            runAnimation: function () {
                if (this.state !== 'READY' && this.state !== 'FINISHED') return;

                this.prepareTimeline();
                this.state = 'RUNNING';
                this.timeIdx = 0;
                this.updateUI();
                document.getElementById('status-panel').style.display = 'block';

                // Play Loop
                this.playLoop();
            },

            playLoop: async function () {
                // If we reached the end
                if (this.timeIdx >= this.timeline.length - 1) {
                    this.finish();
                    return;
                }

                const currentSnap = this.timeline[this.timeIdx];
                const nextSnap = this.timeline[this.timeIdx + 1];

                // Update Status Panel
                this.updateStatus(nextSnap);

                // If Next is ASSIGN: Just change colors (Fast)
                if (nextSnap.phase === 'ASSIGN') {
                    this.applySnapshot(nextSnap);
                    this.timeIdx++;
                    setTimeout(() => this.playLoop(), 400); // Small pause to see color change
                }
                // If Next is UPDATE: Interpolate Movement (Smooth)
                else if (nextSnap.phase === 'UPDATE') {
                    const startC = currentSnap.centroids;
                    const endC = nextSnap.centroids;
                    const duration = 500; // ms
                    const startTime = performance.now();

                    const animateMove = (now) => {
                        const t = Math.min((now - startTime) / duration, 1);
                        // Ease Out Cubic
                        const ease = 1 - Math.pow(1 - t, 3);

                        // Lerp Centroids
                        const lerpedC = startC.map((c, i) => ({
                            x: Utils.lerp(c.x, endC[i].x, ease),
                            y: Utils.lerp(c.y, endC[i].y, ease)
                        }));

                        this.renderer.clear();
                        this.renderer.drawVoronoi(lerpedC, document.getElementById('check-voronoi').checked);
                        this.renderer.drawPoints(this.points); // Points color doesn't change here
                        this.renderer.drawCentroids(lerpedC, true);

                        if (t < 1) {
                            requestAnimationFrame(animateMove);
                        } else {
                            this.timeIdx++;
                            this.playLoop(); // Next step
                        }
                    };
                    requestAnimationFrame(animateMove);
                }
                else {
                    this.timeIdx++;
                    this.playLoop();
                }
            },

            /* STEPPING LOGIC */
            stepForward: function () {
                if (this.state === 'READY') {
                    this.prepareTimeline();
                    this.state = 'STEPPING';
                    this.timeIdx = 0;
                    this.updateUI();
                    document.getElementById('status-panel').style.display = 'block';
                }

                if (this.timeIdx < this.timeline.length - 1) {
                    this.timeIdx++;
                    const snap = this.timeline[this.timeIdx];
                    this.applySnapshot(snap);
                    this.updateStatus(snap);

                    if (this.timeIdx === this.timeline.length - 1) {
                        this.finish();
                    }
                }
            },

            applySnapshot: function (snap) {
                // Update Points
                if (snap.phase !== 'INIT') {
                    this.points.forEach((p, i) => {
                        p.color = Utils.getClusterColor(snap.assignments[i]);
                    });
                }
                this.renderCustom(snap.centroids);
            },

            updateStatus: function (snap) {
                const badge = document.getElementById('stat-phase');
                const iter = document.getElementById('stat-iter');
                const inert = document.getElementById('stat-inertia');

                iter.innerText = snap.iter || 0;
                inert.innerText = Utils.fmtNum(snap.inertia);

                if (snap.phase === 'ASSIGN') {
                    badge.innerText = 'Assigning Points';
                    badge.className = 'status-badge bg-assign';
                } else if (snap.phase === 'UPDATE') {
                    badge.innerText = 'Moving Centroids';
                    badge.className = 'status-badge bg-update';
                } else {
                    badge.innerText = 'Finished';
                    badge.className = 'status-badge bg-done';
                }
            },

            finish: function () {
                this.state = 'FINISHED';
                this.updateUI();
                this.toast('Convergence Reached');

                // Show Results
                const box = document.getElementById('result-box');
                box.style.display = 'block';
                document.getElementById('res-ai-inertia').innerText = Utils.fmtNum(this.aiFinalInertia);
                document.getElementById('res-ai-iter').innerText = this.timeline[this.timeline.length - 1].iter;

                // Analysis Logic
                const diff = ((this.userInertia - this.aiFinalInertia) / this.userInertia) * 100;
                const summary = document.getElementById('res-summary');

                if (diff > 1) {
                    summary.innerHTML = `<strong>Analysis:</strong> The algorithm found a solution that is <span style="color:#008000; font-weight:bold">${diff.toFixed(1)}% more efficient</span> (lower inertia) than your placement.`;
                } else if (diff < -1) {
                    summary.innerHTML = `<strong>Outstanding!</strong> You beat the algorithm by <span style="color:#E3120B; font-weight:bold">${Math.abs(diff).toFixed(1)}%</span>. K-Means sometimes gets stuck in local minima, but you found the global optimum.`;
                } else {
                    summary.innerHTML = `<strong>Tie:</strong> Your intuition matches the algorithm's mathematical convergence almost perfectly.`;
                }
            },

            /* RENDER HELPERS */
            renderStatic: function () {
                this.renderer.clear();
                this.renderer.drawVoronoi(this.userCentroids, document.getElementById('check-voronoi').checked);
                this.renderer.drawPoints(this.points);
                this.renderer.drawCentroids(this.userCentroids, this.state === 'READY');
            },

            renderCustom: function (cents) {
                this.renderer.clear();
                this.renderer.drawVoronoi(cents, document.getElementById('check-voronoi').checked);
                this.renderer.drawPoints(this.points);
                this.renderer.drawCentroids(cents, true);
            },

            toast: function (msg) {
                const t = document.getElementById('overlay-ui');
                t.style.opacity = 0;
                setTimeout(() => { t.innerHTML = msg; t.style.opacity = 1; }, 200);
            },

            updateUI: function () {
                const btnRun = document.getElementById('btn-run');
                const btnStep = document.getElementById('btn-step');

                if (this.state === 'READY') {
                    btnRun.disabled = false; btnRun.innerText = "Run Algorithm";
                    btnStep.disabled = false;
                } else if (this.state === 'RUNNING') {
                    btnRun.disabled = true; btnRun.innerText = "Running...";
                    btnStep.disabled = true;
                } else if (this.state === 'STEPPING') {
                    btnRun.disabled = true;
                    btnStep.disabled = false;
                } else if (this.state === 'FINISHED') {
                    btnRun.disabled = true; btnRun.innerText = "Converged";
                    btnStep.disabled = true;
                } else {
                    btnRun.disabled = true;
                    btnStep.disabled = true;
                }
            },

            toggleVoronoi: function () {
                // Determine which centroids to draw based on state
                if (this.state === 'RUNNING' || this.state === 'FINISHED' || this.state === 'STEPPING') {
                    // Use current timeline index centroids
                    if (this.timeline.length > 0) this.applySnapshot(this.timeline[this.timeIdx]);
                } else {
                    this.renderStatic();
                }
            }
        };

        function updateVal(id, val) { document.getElementById(id).innerText = val; }

        // Init
        window.onload = () => Game.init();

    </script>
</body>

</html>
